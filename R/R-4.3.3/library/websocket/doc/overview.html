<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />

<meta name="viewport" content="width=device-width, initial-scale=1" />


<meta name="date" content="2019-03-18" />

<title>Overview</title>

<script>// Pandoc 2.9 adds attributes on both header and div. We remove the former (to
// be compatible with the behavior of Pandoc < 2.8).
document.addEventListener('DOMContentLoaded', function(e) {
  var hs = document.querySelectorAll("div.section[class*='level'] > :first-child");
  var i, h, a;
  for (i = 0; i < hs.length; i++) {
    h = hs[i];
    if (!/^h[1-6]$/i.test(h.tagName)) continue;  // it should be a header h1-h6
    a = h.attributes;
    while (a.length > 0) h.removeAttribute(a[0].name);
  }
});
</script>
<script>// Hide empty <a> tag within highlighted CodeBlock for screen reader accessibility (see https://github.com/jgm/pandoc/issues/6352#issuecomment-626106786) -->
// v0.0.1
// Written by JooYoung Seo (jooyoung@psu.edu) and Atsushi Yasumoto on June 1st, 2020.

document.addEventListener('DOMContentLoaded', function() {
  const codeList = document.getElementsByClassName("sourceCode");
  for (var i = 0; i < codeList.length; i++) {
    var linkList = codeList[i].getElementsByTagName('a');
    for (var j = 0; j < linkList.length; j++) {
      if (linkList[j].innerHTML === "") {
        linkList[j].setAttribute('aria-hidden', 'true');
      }
    }
  }
});
</script>

<style type="text/css">
  code{white-space: pre-wrap;}
  span.smallcaps{font-variant: small-caps;}
  span.underline{text-decoration: underline;}
  div.column{display: inline-block; vertical-align: top; width: 50%;}
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  ul.task-list{list-style: none;}
    </style>


<style type="text/css">
  code {
    white-space: pre;
  }
  .sourceCode {
    overflow: visible;
  }
</style>
<style type="text/css" data-origin="pandoc">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */

</style>
<script>
// apply pandoc div.sourceCode style to pre.sourceCode instead
(function() {
  var sheets = document.styleSheets;
  for (var i = 0; i < sheets.length; i++) {
    if (sheets[i].ownerNode.dataset["origin"] !== "pandoc") continue;
    try { var rules = sheets[i].cssRules; } catch (e) { continue; }
    for (var j = 0; j < rules.length; j++) {
      var rule = rules[j];
      // check if there is a div.sourceCode rule
      if (rule.type !== rule.STYLE_RULE || rule.selectorText !== "div.sourceCode") continue;
      var style = rule.style.cssText;
      // check if color or background-color is set
      if (rule.style.color === '' && rule.style.backgroundColor === '') continue;
      // replace div.sourceCode by a pre.sourceCode rule
      sheets[i].deleteRule(j);
      sheets[i].insertRule('pre.sourceCode{' + style + '}', j);
    }
  }
})();
</script>




<style type="text/css">body {
background-color: #fff;
margin: 1em auto;
max-width: 700px;
overflow: visible;
padding-left: 2em;
padding-right: 2em;
font-family: "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;
font-size: 14px;
line-height: 1.35;
}
#TOC {
clear: both;
margin: 0 0 10px 10px;
padding: 4px;
width: 400px;
border: 1px solid #CCCCCC;
border-radius: 5px;
background-color: #f6f6f6;
font-size: 13px;
line-height: 1.3;
}
#TOC .toctitle {
font-weight: bold;
font-size: 15px;
margin-left: 5px;
}
#TOC ul {
padding-left: 40px;
margin-left: -1.5em;
margin-top: 5px;
margin-bottom: 5px;
}
#TOC ul ul {
margin-left: -2em;
}
#TOC li {
line-height: 16px;
}
table {
margin: 1em auto;
border-width: 1px;
border-color: #DDDDDD;
border-style: outset;
border-collapse: collapse;
}
table th {
border-width: 2px;
padding: 5px;
border-style: inset;
}
table td {
border-width: 1px;
border-style: inset;
line-height: 18px;
padding: 5px 5px;
}
table, table th, table td {
border-left-style: none;
border-right-style: none;
}
table thead, table tr.even {
background-color: #f7f7f7;
}
p {
margin: 0.5em 0;
}
blockquote {
background-color: #f6f6f6;
padding: 0.25em 0.75em;
}
hr {
border-style: solid;
border: none;
border-top: 1px solid #777;
margin: 28px 0;
}
dl {
margin-left: 0;
}
dl dd {
margin-bottom: 13px;
margin-left: 13px;
}
dl dt {
font-weight: bold;
}
ul {
margin-top: 0;
}
ul li {
list-style: circle outside;
}
ul ul {
margin-bottom: 0;
}
pre, code {
background-color: #f7f7f7;
border-radius: 3px;
color: #333;
white-space: pre-wrap; 
}
pre {
border-radius: 3px;
margin: 5px 0px 10px 0px;
padding: 10px;
}
pre:not([class]) {
background-color: #f7f7f7;
}
code {
font-family: Consolas, Monaco, 'Courier New', monospace;
font-size: 85%;
}
p > code, li > code {
padding: 2px 0px;
}
div.figure {
text-align: center;
}
img {
background-color: #FFFFFF;
padding: 2px;
border: 1px solid #DDDDDD;
border-radius: 3px;
border: 1px solid #CCCCCC;
margin: 0 5px;
}
h1 {
margin-top: 0;
font-size: 35px;
line-height: 40px;
}
h2 {
border-bottom: 4px solid #f7f7f7;
padding-top: 10px;
padding-bottom: 2px;
font-size: 145%;
}
h3 {
border-bottom: 2px solid #f7f7f7;
padding-top: 10px;
font-size: 120%;
}
h4 {
border-bottom: 1px solid #f7f7f7;
margin-left: 8px;
font-size: 105%;
}
h5, h6 {
border-bottom: 1px solid #ccc;
font-size: 105%;
}
a {
color: #0033dd;
text-decoration: none;
}
a:hover {
color: #6666ff; }
a:visited {
color: #800080; }
a:visited:hover {
color: #BB00BB; }
a[href^="http:"] {
text-decoration: underline; }
a[href^="https:"] {
text-decoration: underline; }

code > span.kw { color: #555; font-weight: bold; } 
code > span.dt { color: #902000; } 
code > span.dv { color: #40a070; } 
code > span.bn { color: #d14; } 
code > span.fl { color: #d14; } 
code > span.ch { color: #d14; } 
code > span.st { color: #d14; } 
code > span.co { color: #888888; font-style: italic; } 
code > span.ot { color: #007020; } 
code > span.al { color: #ff0000; font-weight: bold; } 
code > span.fu { color: #900; font-weight: bold; } 
code > span.er { color: #a61717; background-color: #e3d2d2; } 
</style>




</head>

<body>




<h1 class="title toc-ignore">Overview</h1>
<h4 class="date">2019-03-18</h4>



<p><code>websocket</code> is a <a href="https://en.wikipedia.org/wiki/WebSocket">WebSocket</a> client package for R backed by the <a href="https://github.com/zaphoyd/websocketpp">websocketpp</a> C++ library.</p>
<p>WebSocket clients are most commonly used from <a href="https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API/Writing_WebSocket_client_applications">JavaScript in a web browser</a>, and their use in R with this package is not much different. The experience of using <code>websocket</code> is designed to be similar to the experience of using WebSockets in a browser.</p>
<p>Like WebSockets in a browser, <code>websocket</code> makes it easy to asynchronously process data from a WebSocket server. In the context of an R or Shiny application, this functionality is useful for incrementally consuming data from an external data source presented as a WebSocket server.</p>
<p>The I/O for a WebSocket happens on a separate thread from the main R thread; there is one thread for each WebSocket.</p>
<div id="creating-websockets" class="section level2">
<h2>Creating WebSockets</h2>
<p>WebSockets are represented as instances of an <a href="https://github.com/r-lib/R6">R6</a> object, and are created with <code>$new()</code>:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1"></a>ws &lt;-<span class="st"> </span>WebSocket<span class="op">$</span><span class="kw">new</span>(<span class="st">&quot;ws://echo.websocket.org/&quot;</span>)</span></code></pre></div>
<p>By default, and similarly to how WebSockets in JavaScript work, constructing a WebSocket with <code>$new()</code> will automatically initiate the WebSocket connection. In normal usage, such as in a Shiny app or from within a function, this default behavior is ideal. When run interactively from the R console however, the default behavior is problematic. The reason is that the connection will open before the user is given an opportunity to register any event handlers, meaning messages from the server could be dropped.</p>
<p>So, in the console, WebSockets should be created like this:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1"></a>ws &lt;-<span class="st"> </span>WebSocket<span class="op">$</span><span class="kw">new</span>(<span class="st">&quot;ws://echo.websocket.org/&quot;</span>, <span class="dt">autoConnect =</span> <span class="ot">FALSE</span>)</span>
<span id="cb2-2"><a href="#cb2-2"></a><span class="co"># Set up callbacks here...</span></span>
<span id="cb2-3"><a href="#cb2-3"></a>ws<span class="op">$</span><span class="kw">connect</span>()</span></code></pre></div>
</div>
<div id="interaction-with-later" class="section level2">
<h2>Interaction with <code>later</code></h2>
<p>The technical reason that <code>autoConnect = FALSE</code> is necessary at the console has to do with how <a href="https://github.com/r-lib/later">later</a> works. <code>later</code> is a package that provides an event loop for R, and the <code>websocket</code> package uses it to schedule callbacks that run in response to WebSocket events (like incoming messages).</p>
<p>When a function has been put in to the queue with <code>later</code>, there are two ways it could be executed. One way is when <code>later::run_now()</code> is called. The second way is when the R console is idle (and the R call stack is empty): when that happens, <code>later</code> will automatically execute callbacks from the queue.</p>
<p>When running a block of code like this in a function, or surrounded with <code>{</code> and <code>}</code>, the console does not have a chance to be idle in between the lines of code:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1"></a>{</span>
<span id="cb3-2"><a href="#cb3-2"></a>  ws &lt;-<span class="st"> </span>WebSocket<span class="op">$</span><span class="kw">new</span>(<span class="st">&quot;ws://echo.websocket.org/&quot;</span>)</span>
<span id="cb3-3"><a href="#cb3-3"></a>  ws<span class="op">$</span><span class="kw">onOpen</span>(<span class="cf">function</span>(event) { <span class="kw">message</span>(<span class="st">&quot;websocket opened&quot;</span>) })</span>
<span id="cb3-4"><a href="#cb3-4"></a>}</span></code></pre></div>
<p>In this code, the WebSocket has queued a connection attempt before <code>ws$onOpen()</code> is called. However, the <code>ws$onOpen()</code> runs <em>before</em> R tries to call any <code>onOpen</code> callbacks, because there were no idle “ticks” between the two lines of code for <code>later</code> to respond to any opened connections.</p>
<p>(Technical note: <code>websocket</code> runs the I/O on a separate thread; when an event occurs, like an open event or message, it uses <code>later</code> to schedule a callback to run on the main R thread. In the case above, the WebSocket connection could actually be opened – on the I/O thread – before the main R thread calls <code>ws$onOpen()</code> to set up the callback. If that happened it would only be able to schedule the invocation of the <code>onOpen</code> callback immediately; only at a later point in time, when the R console is idle, or when <code>later::run_now()</code> is called, would it be able to actually execute the callbacks. So in the example above, the <code>onOpen</code> callback is guaranteed to run when the connection is successfully opened.)</p>
<p>Because <code>$new()</code> only <em>schedules</em> the work of connecting — it does not perform it immediately — it’s safe within a code block to attach handlers, because none of them can possibly run until after the enclosing block returns.</p>
</div>
<div id="adding-handlers" class="section level2">
<h2>Adding handlers</h2>
<p>After a <code>WebSocket</code> object is created, you have an opportunity to associate handler functions with various WebSocket events using the following R6 methods:</p>
<ol style="list-style-type: decimal">
<li><code>$onOpen()</code>: Invoked when the connection is first opened</li>
<li><code>$onMessage()</code>: Invoked when a message is received from the server</li>
<li><code>$onClose()</code>: Invoked when the client or server closes the connection</li>
<li><code>$onError()</code>: Invoked when an error occurs</li>
</ol>
<p>For example, the following code instantiates a WebSocket, installs an <code>onOpen</code> handler, and prints a message once the WebSocket is open:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1"></a>{</span>
<span id="cb4-2"><a href="#cb4-2"></a>  ws &lt;-<span class="st"> </span>WebSocket<span class="op">$</span><span class="kw">new</span>(<span class="st">&quot;ws://echo.websocket.org/&quot;</span>)</span>
<span id="cb4-3"><a href="#cb4-3"></a>  ws<span class="op">$</span><span class="kw">onOpen</span>(<span class="cf">function</span>(event) {</span>
<span id="cb4-4"><a href="#cb4-4"></a>    <span class="kw">cat</span>(<span class="st">&quot;connected</span><span class="ch">\n</span><span class="st">&quot;</span>)</span>
<span id="cb4-5"><a href="#cb4-5"></a>  })</span>
<span id="cb4-6"><a href="#cb4-6"></a>}</span></code></pre></div>
<blockquote>
<p>Note that because the <code>$new()</code> and <code>$onOpen()</code> calls are within the same code block, <code>autoConnect</code> does not need to be <code>FALSE</code>.</p>
</blockquote>
<div id="event-environment" class="section level3">
<h3>Event environment</h3>
<p>Every handler function is passed an <code>event</code> environment. This environment contains at least the entry <code>target</code>, which is a reference to the WebSocket object on which the event occurred.</p>
<p>In addition to <code>target</code>, other entries are available depending on the handler type:</p>
<ul>
<li><code>$onMessage()</code>
<ul>
<li><code>data</code>: Text or binary data received from the server, as a character vector or raw vector, respectively</li>
</ul></li>
<li><code>$onClose()</code>
<ul>
<li><code>code</code>: The numeric <a href="https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent">close code</a></li>
<li><code>reason</code>: Character vector, the reason for closing</li>
</ul></li>
<li><code>$onError()</code>
<ul>
<li><code>message</code>: Character vector, an error message</li>
</ul></li>
</ul>
</div>
</div>
<div id="removing-handlers" class="section level2">
<h2>Removing handlers</h2>
<p>Multiple handler functions for the same event type can be added to the WebSocket by repeatedly calling a handler registration method such as <code>$onMessage()</code>.</p>
<p>The return value of every registration method is a zero-argument function that may be invoked to <strong>deregister</strong> the handler function.</p>
<p>The following is an example of an <code>$onMessage()</code> handler that immediately removes itself:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1"></a>{</span>
<span id="cb5-2"><a href="#cb5-2"></a>  ws &lt;-<span class="st"> </span>WebSocket<span class="op">$</span><span class="kw">new</span>(<span class="st">&quot;ws://echo.websocket.org/&quot;</span>)</span>
<span id="cb5-3"><a href="#cb5-3"></a>  removeThis &lt;-<span class="st"> </span>ws<span class="op">$</span><span class="kw">onMessage</span>(<span class="cf">function</span>(event) {</span>
<span id="cb5-4"><a href="#cb5-4"></a>    <span class="kw">cat</span>(<span class="st">&quot;this is the last time i&#39;ll run</span><span class="ch">\n</span><span class="st">&quot;</span>)</span>
<span id="cb5-5"><a href="#cb5-5"></a>    <span class="kw">removeThis</span>()</span>
<span id="cb5-6"><a href="#cb5-6"></a>  })</span>
<span id="cb5-7"><a href="#cb5-7"></a>  ws<span class="op">$</span><span class="kw">onOpen</span>(<span class="cf">function</span>(event) {</span>
<span id="cb5-8"><a href="#cb5-8"></a>    ws<span class="op">$</span><span class="kw">send</span>(<span class="st">&quot;one&quot;</span>)</span>
<span id="cb5-9"><a href="#cb5-9"></a>    ws<span class="op">$</span><span class="kw">send</span>(<span class="st">&quot;two&quot;</span>)</span>
<span id="cb5-10"><a href="#cb5-10"></a>  })</span>
<span id="cb5-11"><a href="#cb5-11"></a>}</span></code></pre></div>
<p>Even though <code>ws$send()</code> is called twice in the <code>$onOpen()</code> handler function, the <code>$onMessage()</code> handler function is only run once.</p>
<div id="other-notes" class="section level3">
<h3>Other notes</h3>
<ul>
<li>As long as a WebSocket object has an open connection, it will not be eligible for garbage collection, even if you lose all your references to the object, because the callback scheduling system maintains a reference to the object. This means that any callbacks on the WebSocket will continue to execute. If the connection is closed, the callback scheduling system will drop its references to the WebSocket object, and it will then be eligible for garbage collection.</li>
</ul>
</div>
</div>



<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
